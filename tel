#!/usr/bin/env python3.6
#
# This file is part of teld.
#
# teld is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# teld is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with teld.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon process for managing the telescope"""

# pylint: disable=invalid-name
# pylint: disable=too-many-locals
# pylint: disable=too-many-return-statements

import math
import os
import sys
import time
import socket
import struct
from warwick.rasa.telescope import CommandStatus, TelescopeState, PierSide
from warwick.observatory.common import daemons

TELD_HOST = daemons.rasa_telescope.host
TELD_PORT = daemons.rasa_telescope.port

# This timeout is used for an initial ping before running the real command
# The real commands may take much longer than this, so we can't apply the timeout there.
TEL_PING_TIMEOUT = 5

SCRIPT_NAME = os.path.basename(sys.argv[0])

# Positions in degrees (alt, az)
PARK_POSITIONS = {
    'stow': (1, 300, 'general purpose park protecting the mirror and instrument'),
    'zenith': (90, 0, 'park at zenith for maintenance tasks'),
}

FMT_YELLOW = '\033[93m'
FMT_GREEN = '\033[92m'
FMT_RED = '\033[91m'
FMT_BOLD = '\033[1m'
FMT_CLEAR = '\033[0m'

TELESCOPE_STATE_FORMATS = {
    0: FMT_BOLD + FMT_RED,
    1: FMT_BOLD + FMT_YELLOW,
    2: FMT_BOLD + FMT_YELLOW,
    3: FMT_BOLD + FMT_RED,
    4: FMT_BOLD + FMT_GREEN
}

TWO_DOUBLES = struct.Struct('dd')
FOUR_DOUBLES = struct.Struct('dddd')
TEL_STATUS = struct.Struct('cdddddddc')
DOME_STATUS = struct.Struct('cc')


def bytes_to_status(status):
    return int.from_bytes(status, sys.byteorder)


def run_command(command):
    """Prints the message associated with a status code and returns the code"""
    try:
        ret = command()
    except KeyboardInterrupt:
        # ctrl-c terminates the running command
        ret = stop()

        # Report successful stop
        if ret == 0:
            ret = -100
    except socket.timeout:
        ret = -101
    except ConnectionRefusedError:
        ret = -101

    # Print message associated with error codes, except for -1 (error handled locally)
    if ret != -1 and ret != 0:
        print(CommandStatus.message(ret))
    sys.exit(ret)


def sexagesimal(angle):
    """Formats a decimal number in sexagesimal format"""
    negative = angle < 0
    angle = math.fabs(angle)

    degrees = int(angle)
    angle = (angle - degrees) * 60
    minutes = int(angle)
    seconds = (angle - minutes) * 60

    if negative:
        degrees *= -1

    return '{:d}:{:02d}:{:05.2f}'.format(degrees, minutes, seconds)


def parse_sexagesimal(string):
    """Converts a sexagesimal string to decimal"""
    parts = string.split(':')
    if len(parts) != 3:
        raise ValueError('Invalid input')

    a = float(parts[0])
    b = math.copysign(float(parts[1]), a)
    c = math.copysign(float(parts[2]), a)

    return a + b / 60 + c / 3600


def parse_ra(ra_string):
    """Converts a HH:MM:SS Dec string to degrees"""
    return parse_sexagesimal(ra_string) * 15


def parse_dec(dec_string):
    """Converts a DD:MM:SS Dec string to degrees"""
    return parse_sexagesimal(dec_string)


def park(args):
    """Slews the telescope to a named park position"""
    if len(args) == 1:
        if args[0] not in PARK_POSITIONS:
            print('error: unknown park position \'' + args[0] + '\'')
            return -1

        alt_degrees, az_degrees, _ = PARK_POSITIONS.get(args[0])
        ping_teld()
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
            teld.connect((TELD_HOST, TELD_PORT))
            teld.sendall(b'\x05')
            teld.sendall(TWO_DOUBLES.pack(alt_degrees, az_degrees))
            return bytes_to_status(teld.recv(1))

    print('usage: {} park <position>'.format(SCRIPT_NAME))
    print()
    for p in PARK_POSITIONS:
        print('   {:6s}    {}'.format(p, PARK_POSITIONS[p][2]))
    print()
    return -1


def horizon(args):
    """Slews the telescope to a specified Alt,Az position"""
    if len(args) != 2:
        print('usage: {} horizon <DD:MM:SS.S> <DD:MM:SS.S>'.format(SCRIPT_NAME))
        return -1

    try:
        alt_degrees = parse_dec(args[0])
    except ValueError:
        print('error: failed to parse \'' + args[0] + '\' as a DD:MM:SS.S altitude.')
        return -1

    try:
        az_degrees = parse_dec(args[1])
    except ValueError:
        print('error: failed to parse \'' + args[1] + '\' as a DD:MM:SS.S azimuth.')
        return -1

    ping_teld()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x05')
        teld.sendall(TWO_DOUBLES.pack(alt_degrees, az_degrees))
        return bytes_to_status(teld.recv(1))


def track(args):
    """Slews the telescope to a specified RA,Dec position and begins tracking"""
    if len(args) != 2 and len(args) != 4:
        print('usage: {} track <HH:MM:SS.S> <DD:MM:SS.S> [<delta-ra> <delta-dec>]'.format(
            SCRIPT_NAME))
        return -1

    try:
        ra_degrees = parse_ra(args[0])
    except ValueError:
        print('error: failed to parse \'' + args[0] + '\' as a HH:MM:SS.S right ascension.')
        return -1

    try:
        dec_degrees = parse_dec(args[1])
    except ValueError:
        print('error: failed to parse \'' + args[1] + '\' as a DD:MM:SS.S declination.')
        return -1

    delta_ra_arcsec_per_sec = delta_dec_arcsec_per_sec = 0
    if len(args) == 4:
        try:
            delta_ra_arcsec_per_sec = float(args[2])
        except ValueError:
            print('error: failed to parse \'' + args[2] + '\' as a number.')
            return -1

        try:
            delta_dec_arcsec_per_sec = float(args[3])
        except ValueError:
            print('error: failed to parse \'' + args[3] + '\' as a number.')
            return -1

    ping_teld()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x06')
        teld.sendall(FOUR_DOUBLES.pack(ra_degrees, dec_degrees, delta_ra_arcsec_per_sec, delta_dec_arcsec_per_sec))
        return bytes_to_status(teld.recv(1))

def offset(args):
    """Offsets the telescope by a specified delta RA,Dec"""
    if len(args) != 2:
        print('usage: {} offset <HH:MM:SS.S> <DD:MM:SS.S>'.format(SCRIPT_NAME))
        return -1

    try:
        offset_ra_degrees = parse_ra(args[0])
    except ValueError:
        print('error: failed to parse \'' + args[0] + '\' as a HH:MM:SS.S right ascension.')
        return -1

    try:
        offset_dec_degrees = parse_dec(args[1])
    except ValueError:
        print('error: failed to parse \'' + args[1] + '\' as a DD:MM:SS.S declination.')
        return -1

    ping_teld()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x07')
        teld.sendall(TWO_DOUBLES.pack(offset_ra_degrees, offset_dec_degrees))
        return bytes_to_status(teld.recv(1))


def rates(args):
    """Sets a custom tracking rate"""
    if len(args) == 1 and args[0] == 'sidereal':
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
            teld.settimeout(5)
            teld.connect((TELD_HOST, TELD_PORT))
            teld.sendall(b'\x08')
            teld.sendall(TWO_DOUBLES.pack(0, 0))
            return bytes_to_status(teld.recv(1))

    if len(args) != 2:
        print('usage: {} offset [<ra arcsec/sec> <dec arcsec/sec>|sidereal]'.format(SCRIPT_NAME))
        return -1

    try:
        ra_arcsec_per_sec = float(args[0])
    except ValueError:
        print('error: failed to parse \'' + args[0] + '\' as a tracking rate.')
        return -1

    try:
        dec_arcsec_per_sec = float(args[1])
    except ValueError:
        print('error: failed to parse \'' + args[1] + '\' as a tracking rate.')
        return -1

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.settimeout(5)
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x08')
        teld.sendall(TWO_DOUBLES.pack(ra_arcsec_per_sec, dec_arcsec_per_sec))
        return bytes_to_status(teld.recv(1))


def status():
    """Reports the current telescope status"""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.settimeout(5)
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x09')
        status = teld.recv(1)
        if len(status) == 0:
            return 1

        if int.from_bytes(status, sys.byteorder) == 0:
            data = TEL_STATUS.unpack(teld.recv(TEL_STATUS.size))
            data = {
                'state': bytes_to_status(data[0]),
                'alt': data[1],
                'az': data[2],
                'ra': data[3],
                'dec': data[4],
                'ra_rate': data[5],
                'dec_rate': data[6],
                'ha': data[7],
                'pier_side': bytes_to_status(data[8])
            }
        else:
            data = {
                'state': 0
            }

    state_desc = TELESCOPE_STATE_FORMATS[data['state']] + TelescopeState.Names[data['state']] \
        + FMT_CLEAR

    # Telescope is disabled
    if data['state'] < TelescopeState.Slewing:
        print('   Telescope is {}'.format(state_desc))
        return 0

    ra_desc = FMT_BOLD + sexagesimal(data['ra'] / 15) + FMT_CLEAR
    dec_desc = FMT_BOLD + sexagesimal(data['dec']) + FMT_CLEAR
    alt_desc = FMT_BOLD + sexagesimal(data['alt']) + FMT_CLEAR
    az_desc = FMT_BOLD + sexagesimal(data['az']) + FMT_CLEAR
    ha_desc = FMT_BOLD + sexagesimal(data['ha'] / 15) + FMT_CLEAR

    ra_rate_desc = FMT_BOLD + '{:.3f} arcsec/sec'.format(data['ra_rate']) + FMT_CLEAR
    dec_rate_desc = FMT_BOLD + '{:.3f} arcsec/sec'.format(data['dec_rate']) + FMT_CLEAR
    pier_desc = FMT_BOLD + PierSide.Names[data['pier_side']] + FMT_CLEAR
    print('   Telescope is {}'.format(state_desc))
    print('   RA is ' + ra_desc)
    print('   Dec is ' + dec_desc)
    print('   HA is ' + ha_desc)
    if data['state'] == TelescopeState.Tracking:
        print('   RA rate is ' + ra_rate_desc)
        print('   Dec rate is ' + dec_rate_desc)
    print('   Altitude is ' + alt_desc)
    print('   Azimuth is ' + az_desc)
    print('   Payload is on ' + pier_desc + ' side')

    return 0


def dome():
    """Reports the current dome status"""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.settimeout(5)
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x0A')
        status = teld.recv(1)
        if len(status) == 0:
            return 1

        if int.from_bytes(status, sys.byteorder) == 0:
            dome, environment = DOME_STATUS.unpack(teld.recv(DOME_STATUS.size))
            print('Dome is ' + ['Closed', 'Open', 'Moving', 'Timeout'][bytes_to_status(dome)])
            print('Environment is {}'.format('SAFE' if bytes_to_status(environment) else 'UNSAFE'))
            return 0

        return 1


def stop():
    """Stops any active telescope movement"""
    ping_teld()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x04')
        return bytes_to_status(teld.recv(1))


def initialize():
    """Enables and homes the mount"""
    ping_teld()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x02')
        return bytes_to_status(teld.recv(1))


def shutdown():
    """Disables the mount"""
    ping_teld()
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x03')
        return bytes_to_status(teld.recv(1))


def reboot():
    """Reboots the mount"""
    shutdown()
    time.sleep(5)
    return initialize()


def ping_teld():
    """Check that teld is alive"""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as teld:
        teld.settimeout(TEL_PING_TIMEOUT)
        teld.connect((TELD_HOST, TELD_PORT))
        teld.sendall(b'\x01')
        bytes_to_status(teld.recv(1))


def print_usage():
    """Prints the utility help"""
    print('usage: {} <command> [<args>]'.format(SCRIPT_NAME))
    print()
    print('general commands:')
    print('   status    print a human-readable summary of the telescope status')
    print('   park      park the telescope in a named position')
    print()
    print('observing commands:')
    print('   horizon   slew the telescope to a given Alt, Az')
    print('   track     slew the telescope to a given RA, Dec and track the target')
    print('   offset    offset the telescope by a given delta RA, Dec')
    print('   rates     set a custom tracking rate')
    print('   stop      immediately stop any telescope movement')
    print()
    print('engineering commands:')
    print('   init      initialize and homes the mount')
    print('   kill      disables the mount')
    print('   reboot    kill and reinitialize the telescope daemon')
    print()

    return 0


if __name__ == '__main__':
    if len(sys.argv) == 1:
        sys.exit(print_usage())
    if sys.argv[1] == 'park':
        run_command(lambda: park(sys.argv[2:]))
    elif sys.argv[1] == 'horizon':
        run_command(lambda: horizon(sys.argv[2:]))
    elif sys.argv[1] == 'track':
        run_command(lambda: track(sys.argv[2:]))
    elif sys.argv[1] == 'offset':
        run_command(lambda: offset(sys.argv[2:]))
    elif sys.argv[1] == 'rates':
        run_command(lambda: rates(sys.argv[2:]))
    elif sys.argv[1] == 'status':
        run_command(status)
    elif sys.argv[1] == 'dome':
        run_command(dome)
    elif sys.argv[1] == 'stop':
        run_command(stop)
    elif sys.argv[1] == 'init':
        run_command(initialize)
    elif sys.argv[1] == 'kill':
        run_command(shutdown)
    elif sys.argv[1] == 'reboot':
        run_command(reboot)

    # Command not found
    sys.exit(print_usage())
