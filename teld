#!/usr/bin/env python3.6
#
# This file is part of rasa-teld.
#
# rasa-teld is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# rasa-teld is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with rasa-teld.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling a Paramount ME via Pyro"""

# pylint: disable=invalid-name
# pylint: disable=broad-except
# pylint: disable=bare-except
# pylint: disable=too-many-lines
# pylint: disable=too-many-branches
# pylint: disable=too-many-statements
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-return-statements
# pylint: disable=too-few-public-methods

import datetime
import sys
import threading
import time
import traceback
from astropy.coordinates import Angle, SkyCoord, EarthLocation, get_moon, get_sun
from astropy.time import Time
import astropy.units as u
import Pyro4

# pylint: disable=import-error
import pythoncom
import win32com.client
import pywintypes
# pylint: enable=import-error

from warwick.observatory.common import (
    daemons,
    log,
    TryLock)

from warwick.rasa.telescope import CommandStatus, TelescopeState, PierSide

# Set automatically when generating RPM package
SOFTWARE_VERSION = 'UNKNOWN'

# Delay between status queries (in seconds)
TELSTAT_QUERY_DELAY = 0.5

# Maximum time to find home (in seconds)
INITIALIZE_TIMEOUT = 120
SHUTDOWN_TIMEOUT = 20

# Values from W1m - close enough!
# pylint: disable=no-member
SITE_LOCATION = EarthLocation(
    lat=28.7603135*u.deg,
    lon=-17.8796168*u.deg,
    height=2387*u.m)
# pylint: enable=no-member

class TelError:
    """Return code enum representing error states from the underlying controller"""
    NoError = 0
    Other = 1
    SerialConnectionFailed = 2
    SerialTimeout = 3
    SlewOutsideLimits = 4
    CommandInProgress = 5

class RequestedSlew:
    """Represents a requested slew type and vector"""
    NoSlew, Equatorial, Horizon, EquatorialOffsetFirst, EquatorialOffsetSecond, \
    HorizonOffsetFirst, HorizonOffsetSecond = range(7)

    def __init__(self, a, b, t):
        self.a = a
        self.b = b
        self.type = t

def parse_tel_exception(e):
    """Parses and returns a TelError value from a given exception"""
    if isinstance(e, pywintypes.com_error):
        if e.excepinfo and e.excepinfo[2].startswith('Could not open communications port.'):
            print('Failed to connect to serial port')
            log.error('rasa_teld', 'Failed to connect to serial port')
            return TelError.SerialConnectionFailed
        if e.excepinfo and e.excepinfo[2].startswith('Receive time-out.COMM_TIMEOUT'):
            print('Serial timeout')
            log.error('rasa_teld', 'Serial timeout')
            return TelError.SerialTimeout
        if e.excepinfo and e.excepinfo[2].startswith('Limits exceeded.'):
            print('Requested slew was outside limits')
            log.error('rasa_teld', 'Requested slew was outside limits')
            return TelError.SlewOutsideLimits
        if e.excepinfo and e.excepinfo[2].startswith('Command in progress.'):
            print('Command in progress')
            log.error('rasa_teld', 'Command in progress')
            return TelError.CommandInProgress

    print('Unknown exception:')
    traceback.print_exc(file=sys.stdout)
    log.error('rasa_teld', 'Unknown error communicating with mount')
    return TelError.Other

class TelescopeDaemon:
    """Daemon interface for Paramount subsystems"""
    def __init__(self):
        # Only one command may be active at a time (except for stop)
        self._command_lock = threading.Lock()
        self._slew_condition = threading.Condition()
        self._initialize_shutdown_condition = threading.Condition()

        # COM connections to the underlying control software
        # Must be initialized and used only from the tel thread
        self._telescope = None
        self._thesky = None
        self._utils = None

        # Status code to return from initialization
        self._initialization_status = CommandStatus.Failed

        self._slew_aborted = False
        self._slew_outside_limits = False

        self._slew_lock = threading.Lock()

        # Set by client threads to signal telescope init / shutdown
        self._requested_stop = False
        self._requested_active = False
        self._requested_tracking = False
        self._requested_tracking_rates = None
        self._requested_slew = None

        # Set by tel thread to indicate actual state
        self._state = TelescopeState.Disabled

        self._current_lock = threading.Lock()
        self._current_ra = 0 * u.deg
        self._current_dec = 0 * u.deg
        self._current_ra_rate = 0 * u.arcsec / u.s
        self._current_dec_rate = 0 * u.arcsec / u.s
        self._current_alt = 0 * u.deg
        self._current_az = 0 * u.deg
        self._current_lst = 0 * u.deg
        self._current_ha = 0 * u.deg
        self._current_pier_side = PierSide.Unknown

        tel_status_thread = threading.Thread(target=self.__poll_tel_status)
        tel_status_thread.daemon = True
        tel_status_thread.start()

    def __tel_update_pier_side(self, ha):
        """Updates _current_pier_side based on the given HA"""
        # Don't know for sure!
        if abs(ha) < 5.5 * u.deg:
            return

        if 0 <= ha < 6 * u.hourangle or ha <= -6 * u.hourangle:
            self._current_pier_side = PierSide.East
        else:
            self._current_pier_side = PierSide.West

    def __tel_query_state(self):
        """Update local copies of state variables from talon shared memory segment"""
        try:
            if self._state > TelescopeState.Initializing:
                with self._current_lock:
                    # Query new positions from mount
                    self._telescope.GetRaDec()
                    self._telescope.GetAzAlt()

                    ra_hourangle, dec_degrees = self._utils.PrecessNowTo2000(self._telescope.dRA, self._telescope.dDec)
                    self._current_ra = ra_hourangle * u.hourangle
                    self._current_dec = dec_degrees * u.deg
                    self._current_alt = self._telescope.dAlt * u.deg
                    self._current_az = self._telescope.dAz * u.deg
                    self._current_lst = self._utils.ComputeLocalSiderealTime() * u.hourangle
                    self._current_ha = Angle(self._current_lst - self._current_ra).wrap_at(12 * u.hourangle)

                    if self._state != TelescopeState.Slewing:
                        self.__tel_update_pier_side(self._current_ha)
                        if self._telescope.IsTracking:
                            self._state = TelescopeState.Tracking
                        else:
                            self._state = TelescopeState.Stopped

        except Exception as e:
            parse_tel_exception(e)
            self._requested_active = False

    def __tel_clear_custom_tracking(self, sidereal_tracking):
        tracking = 1 if sidereal_tracking else 0
        # The RA and Dec reported by GetRaDec are wrong unless we first zero then ignore the rates
        self._telescope.SetTracking(tracking, 0, 0, 0)
        self._telescope.SetTracking(tracking, 1, 0, 0)
        with self._current_lock:
            self._current_ra_rate = 0 * u.arcsec / u.s
            self._current_dec_rate = 0 * u.arcsec / u.s

    def __tel_initialize_mount(self):
        print('Initializing mount')
        log.info('rasa_teld', 'Initializing mount')
        try:
            self._state = TelescopeState.Initializing
            if not self._telescope.IsConnected:
                self._telescope.Connect()

            # Home telescope
            self._telescope.FindHome()
            self.__tel_clear_custom_tracking(False)

            self._current_pier_side = PierSide.East
            self._state = TelescopeState.Stopped
            self._initialization_status = CommandStatus.Succeeded
        except Exception as e:
            err = parse_tel_exception(e)
            if err == TelError.SerialConnectionFailed:
                self._initialization_status = CommandStatus.SerialNotAvailable
            elif err == TelError.SerialTimeout:
                self._initialization_status = CommandStatus.SerialTimeout
            else:
                self._initialization_status = CommandStatus.Failed

        if self._initialization_status != CommandStatus.Succeeded:
            self._requested_active = False
            self._current_pier_side = PierSide.Unknown
            self._state = TelescopeState.Disabled

        with self._initialize_shutdown_condition:
            self._initialize_shutdown_condition.notify_all()

    def __tel_shutdown_mount(self):
        print('Shutting down mount')
        log.info('rasa_teld', 'Shutting down mount')
        try:
            # Disable tracking and disconnect
            self.__tel_clear_custom_tracking(False)
            self._thesky.DisconnectTelescope()
        except Exception as e:
            parse_tel_exception(e)

        self._state = TelescopeState.Disabled
        with self._initialize_shutdown_condition:
            self._initialize_shutdown_condition.notify_all()

    def __poll_tel_status(self):
        """Background thread that polls shared memory for the current telescope status"""
        pythoncom.CoInitialize()

        self._thesky = win32com.client.Dispatch("TheSky6.RASCOMTheSky")
        self._telescope = win32com.client.Dispatch("TheSky6.RASCOMTele")
        self._telescope.Asynchronous = True
        self._utils = win32com.client.Dispatch("TheSky6.Utils")

        while True:
            if self._state == TelescopeState.Disabled and self._requested_active:
                self.__tel_initialize_mount()

            if self._state != TelescopeState.Disabled and not self._requested_active:
                self.__tel_shutdown_mount()

            # The rest of the loop only makes sense if the mount is online
            if self._state == TelescopeState.Disabled:
                time.sleep(TELSTAT_QUERY_DELAY)
                continue

            if self._requested_stop:
                try:
                    self._telescope.Abort()
                    self.__tel_clear_custom_tracking(False)
                    self._slew_aborted = True
                    self._requested_stop = False
                except Exception as e:
                    print('Failed to stop slew')
                    log.error('rasa_teld', 'Failed to stop slew')
                    parse_tel_exception(e)
                    self._requested_active = False

            if self._state == TelescopeState.Slewing:
                try:
                    with self._slew_condition:
                        if self._telescope.IsSlewComplete:
                            # Update the pier side
                            self._telescope.GetRaDec()
                            ra_hourangle, _ = self._utils.PrecessNowTo2000(self._telescope.dRA, self._telescope.dDec)
                            lst_hourangle = self._utils.ComputeLocalSiderealTime()
                            ha = Angle((lst_hourangle - ra_hourangle) * u.hourangle).wrap_at(12 * u.hourangle)
                            self.__tel_update_pier_side(ha)

                            # Update the tracking state
                            if self._telescope.IsTracking:
                                self._state = TelescopeState.Tracking
                            else:
                                self._state = TelescopeState.Stopped
                            self._slew_condition.notify_all()

                except Exception as e:
                    print('Failed to check slew status')
                    log.error('rasa_teld', 'Failed to check slew status')
                    parse_tel_exception(e)
                    self._requested_active = False

            with self._slew_lock:
                try:
                    # IsTracking sometimes returns the wrong value, so reset it every tick
                    # This also acts as a heartbeat check, and will throw if the mount goes offline
                    if self._requested_tracking_rates and len(self._requested_tracking_rates) == 2:
                        self._telescope.SetTracking(
                            1, 0,
                            self._requested_tracking_rates[0].to_value(u.arcsec / u.s),
                            self._requested_tracking_rates[1].to_value(u.arcsec / u.s))

                        with self._current_lock:
                            self._current_ra_rate = self._requested_tracking_rates[0]
                            self._current_dec_rate = self._requested_tracking_rates[1]
                    else:
                        self.__tel_clear_custom_tracking(self._requested_tracking)

                except Exception as e:
                    print('Failed to set tracking')
                    log.error('rasa_teld', 'Failed to set tracking')
                    parse_tel_exception(e)
                    self._requested_active = False

                try:
                    if self._state != TelescopeState.Slewing and self._requested_slew is not None:
                        self._slew_aborted = False
                        self._slew_outside_limits = False
                        self._state = TelescopeState.Slewing

                        # Even jogging may cause a pier flip, so we can't assume anything!
                        self._current_pier_side = PierSide.Unknown

                        slew = self._requested_slew
                        if slew.type == RequestedSlew.Horizon:
                            print('Slew to AltAz', slew.a.to(u.deg), slew.b.to(u.deg))
                            self._telescope.SlewToAzAlt(slew.b.to_value(u.deg), slew.a.to_value(u.deg), "Target")
                            self._requested_slew = None
                        elif slew.type == RequestedSlew.HorizonOffsetFirst:
                            print('Offset by Alt', slew.a.to(u.deg))
                            self._telescope.Jog(abs(slew.a.to_value(u.arcmin)), "D" if slew.a < 0 else "U")
                            slew.type = RequestedSlew.HorizonOffsetSecond
                        elif slew.type == RequestedSlew.HorizonOffsetSecond:
                            print('Offset by Az', slew.b.to(u.deg))
                            self._telescope.Jog(abs(slew.b.to_value(u.arcmin)), "L" if slew.b < 0 else "R")
                            self._requested_slew = None
                        elif slew.type == RequestedSlew.Equatorial:
                            print('Slew to RaDec', slew.a.to(u.deg), slew.b.to(u.deg))
                            ra_hourangle, dec_degrees = self._utils.Precess2000ToNow(
                                slew.a.to_value(u.hourangle),
                                slew.b.to_value(u.deg))
                            self._telescope.SlewToRaDec(ra_hourangle, dec_degrees, "Target")
                            self._requested_slew = None
                        elif slew.type == RequestedSlew.EquatorialOffsetFirst:
                            print('Offset by Ra', slew.a.to(u.deg))
                            self._telescope.Jog(abs(slew.a.to_value(u.arcmin)), "W" if slew.a < 0 else "E")
                            slew.type = RequestedSlew.EquatorialOffsetSecond
                        elif slew.type == RequestedSlew.EquatorialOffsetSecond:
                            print('Offset by Dec', slew.b.to(u.deg))
                            self._telescope.Jog(abs(slew.b.to_value(u.arcmin)), "S" if slew.b < 0 else "N")
                            self._requested_slew = None
                except Exception as e:
                    err = parse_tel_exception(e)
                    if err == TelError.SlewOutsideLimits:
                        self._slew_outside_limits = True
                    self._requested_slew = None
                    self._slew_aborted = True

            self.__tel_query_state()

            # Stop tracking if the mount has crossed the meridian
            if self._state == TelescopeState.Tracking and self._current_pier_side != PierSide.Unknown:
                if abs(self._current_ha) < 5.5 * u.deg:
                    if 0 <= self._current_ha < 6 * u.hourangle or self._current_ha <= -6 * u.hourangle:
                        desired_pier_side = PierSide.East
                    else:
                        desired_pier_side = PierSide.West

                    if desired_pier_side != self._current_pier_side:
                        print('Stopped tracking on wrong side of pier')
                        # Stop tracking immediately
                        self.__tel_clear_custom_tracking(False)

                        # Clean up remaining state on the next loop
                        self._requested_stop = True
                        self._requested_tracking = False
                        self._requested_tracking_rates = None

            time.sleep(TELSTAT_QUERY_DELAY)

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current telescope state"""
        data = {
            'state': self._state,
            'state_label': TelescopeState.Names[self._state],
            'software_version': SOFTWARE_VERSION
        }

        if self._state >= TelescopeState.Slewing:
            with self._current_lock:
                timenow = Time(datetime.datetime.utcnow(), scale='utc', location=SITE_LOCATION)
                pointing = SkyCoord(self._current_ra, self._current_dec, frame='fk5')

                # pylint: disable=no-member
                data.update({
                    'ra': self._current_ra.to_value(u.rad),
                    'dec': self._current_dec.to_value(u.rad),
                    'ra_rate': self._current_ra_rate.to_value(u.arcsec / u.s),
                    'dec_rate': self._current_dec_rate.to_value(u.arcsec / u.s),
                    'alt': self._current_alt.to_value(u.rad),
                    'az': self._current_az.to_value(u.rad),
                    'lst': self._current_lst.to_value(u.rad),
                    'ha': self._current_ha.to_value(u.rad),
                    'pier_side': self._current_pier_side,
                    'moon_separation': get_moon(timenow).separation(pointing).rad,
                    'sun_separation': get_sun(timenow).separation(pointing).rad,
                    'site_latitude': SITE_LOCATION.lat.rad,
                    'site_longitude': SITE_LOCATION.lon.rad,
                    'site_elevation': float(SITE_LOCATION.height / u.m),
                })
                # pylint: enable=no-member
        return data

    @Pyro4.expose
    def initialize(self):
        """Enables and homes the mount"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._state != TelescopeState.Disabled:
                return CommandStatus.TelescopeNotDisabled

            with self._initialize_shutdown_condition:
                self._requested_active = True
                self._initialize_shutdown_condition.wait(INITIALIZE_TIMEOUT)

            return self._initialization_status

    @Pyro4.expose
    def shutdown(self):
        """Disables the mount"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._state == TelescopeState.Disabled:
                return CommandStatus.TelescopeNotEnabled

            if self._state == TelescopeState.Initializing:
                return CommandStatus.TelescopeInitializing

            with self._initialize_shutdown_condition:
                self._requested_active = False
                self._requested_stop = True
                self._requested_tracking = False
                self._initialize_shutdown_condition.wait(SHUTDOWN_TIMEOUT)

            if self._state != TelescopeState.Disabled:
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop(self):
        """Stops any active telescope movement"""
        if self._state < TelescopeState.Initializing:
            return CommandStatus.TelescopeNotEnabled

        self._requested_stop = True
        self._requested_tracking = False
        self._requested_tracking_rates = None

        return CommandStatus.Succeeded

    def __slew(self, coordinates, tracking=None, offset=False, altaz=False):
        """Called from a client thread to queue a slew command
           and block until it completes.

           coordinates is a tuple of (ra, dec) if altaz = False
           or (alt, az) if altaz = True

           tracking should be set to False to disable sidereal tracking after the slew

           Returns a CommandStatus with a result code (Succeeded, SlewAborted,
                                                       CoordinatesOutsideLimits)
        """
        with self._slew_lock:
            if tracking is not None:
                self._requested_tracking = tracking

            if offset:
                if altaz:
                    slew_type = RequestedSlew.HorizonOffsetFirst
                else:
                    slew_type = RequestedSlew.EquatorialOffsetFirst
            else:
                if altaz:
                    slew_type = RequestedSlew.Horizon
                else:
                    slew_type = RequestedSlew.Equatorial
            self._requested_slew = RequestedSlew(coordinates[0], coordinates[1], slew_type)

        with self._slew_condition:
            while True:
                self._slew_condition.wait(1)

                if self._state != TelescopeState.Slewing and self._requested_slew is None:
                    break

        if self._slew_outside_limits:
            return CommandStatus.CoordinatesOutsideLimits
        return CommandStatus.SlewAborted if self._slew_aborted else CommandStatus.Succeeded

    @Pyro4.expose
    def slew_altaz(self, alt_radians, az_radians):
        """Moves the telescope to a target"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._state < TelescopeState.Stopped:
                return CommandStatus.TelescopeNotEnabled

            with self._slew_lock:
                self._requested_tracking_rates = None

            return self.__slew((alt_radians * u.rad, az_radians * u.rad), tracking=False, altaz=True)

    @Pyro4.expose
    def track_altaz(self, alt_radians, az_radians):
        """Moves the telescope to a target and starts tracking"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._state < TelescopeState.Stopped:
                return CommandStatus.TelescopeNotEnabled

            with self._slew_lock:
                self._requested_tracking_rates = None

            return self.__slew((alt_radians * u.rad, az_radians * u.rad), tracking=True, altaz=True)

    @Pyro4.expose
    def slew_radec(self, ra_radians, dec_radians):
        """Moves the telescope to a target"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._state < TelescopeState.Stopped:
                return CommandStatus.TelescopeNotEnabled

            with self._slew_lock:
                self._requested_tracking_rates = None

            return self.__slew((ra_radians * u.rad, dec_radians * u.rad), tracking=False)

    @Pyro4.expose
    def track_radec(self, ra_radians, dec_radians, tracking_rates_arcsec_per_sec=None):
        """Moves the telescope to a target and starts tracking"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._state < TelescopeState.Stopped:
                return CommandStatus.TelescopeNotEnabled

            with self._slew_lock:
                if tracking_rates_arcsec_per_sec and len(tracking_rates_arcsec_per_sec) == 2:
                    self._requested_tracking_rates = (
                        tracking_rates_arcsec_per_sec[0] * u.arcsec / u.s,
                        tracking_rates_arcsec_per_sec[1] * u.arcsec / u.s)
                else:
                    self._requested_tracking_rates = None

            return self.__slew((ra_radians * u.rad, dec_radians * u.rad), tracking=True)

    @Pyro4.expose
    def offset_radec(self, ra_delta_radians, dec_delta_radians):
        """Offsets the telescope relative to the current position"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._state < TelescopeState.Stopped:
                return CommandStatus.TelescopeNotEnabled

            return self.__slew((ra_delta_radians * u.rad, dec_delta_radians * u.rad), offset=True)


    @Pyro4.expose
    def track_rates(self, ra_arcsec_per_sec, dec_arcsec_per_sec):
        """Sets a custom tracking rate"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._state < TelescopeState.Stopped:
                return CommandStatus.TelescopeNotEnabled

            with self._slew_lock:
                self._requested_tracking = True
                self._requested_tracking_rates = (
                    ra_arcsec_per_sec * u.arcsec / u.s,
                    dec_arcsec_per_sec * u.arcsec / u.s)
        return CommandStatus.Succeeded

    @Pyro4.expose
    def track_sidereal(self):
        """Resets the tracking to the sidereal rate"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._state < TelescopeState.Stopped:
                return CommandStatus.TelescopeNotEnabled

            with self._slew_lock:
                self._requested_tracking = True
                self._requested_tracking_rates = None
        return CommandStatus.Succeeded

    # pylint: disable=no-self-use
    @Pyro4.expose
    def ping(self):
        """Returns immediately with a success status"""
        return CommandStatus.Succeeded
    # pylint: enable=no-self-use

if __name__ == '__main__':
    daemons.rasa_telescope.launch(TelescopeDaemon())
